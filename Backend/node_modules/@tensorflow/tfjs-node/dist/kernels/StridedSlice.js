"use strict";
/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
Object.defineProperty(exports, "__esModule", { value: true });
var tfjs_1 = require("@tensorflow/tfjs");
var nodejs_kernel_backend_1 = require("../nodejs_kernel_backend");
exports.stridedSliceConfig = {
    kernelName: tfjs_1.StridedSlice,
    backendName: 'tensorflow',
    kernelFunc: function (args) {
        var x = args.inputs.x;
        var backend = args.backend;
        var _a = args.attrs, beginMask = _a.beginMask, endMask = _a.endMask, ellipsisMask = _a.ellipsisMask, newAxisMask = _a.newAxisMask, shrinkAxisMask = _a.shrinkAxisMask;
        var _b = args.attrs, begin = _b.begin, end = _b.end, strides = _b.strides;
        // make a copy because it may be modified in-place further down.
        begin = begin.slice();
        end = end.slice();
        if (strides == null) {
            strides = new Array(begin.length);
        }
        var ellipsisAxes = tfjs_1.backend_util.slice_util.maskToAxes(ellipsisMask);
        if (ellipsisAxes.length > 1) {
            throw new Error('Multiple ellipses in slice is not allowed.');
        }
        if (ellipsisMask !== 0 && newAxisMask !== 0) {
            throw new Error('Using both ellipsisMask and newAxisMask is not yet supported.');
        }
        if (ellipsisMask !== 0 && shrinkAxisMask !== 0) {
            throw new Error('Using both ellipsisMask and shrinkAxisMask is not yet supported.');
        }
        return tfjs_1.tidy(function () {
            var numInterpolatedAxes = x.rank - begin.length;
            // Expand the dims of x based on the newAxisMask.
            var expandAxes = tfjs_1.backend_util.slice_util.maskToAxes(newAxisMask);
            var newShape = x.shape.slice();
            expandAxes.forEach(function (axis) {
                begin[axis] = 0;
                end[axis] = 1;
                newShape.splice(axis, 0, 1);
            });
            x = tfjs_1.reshape(x, newShape);
            var _a = tfjs_1.backend_util.slice_util.getNormalizedAxes(x.shape, ellipsisAxes, numInterpolatedAxes, begin, end, strides, beginMask, endMask, ellipsisMask), normalizedBegin = _a.begin, normalizedEnd = _a.end, normalizedStrides = _a.strides;
            begin = normalizedBegin;
            end = normalizedEnd;
            strides = normalizedStrides;
            var shrinkAxes = tfjs_1.backend_util.slice_util.maskToAxes(shrinkAxisMask);
            // Adjust the ends based on the shrink mask.
            shrinkAxes.forEach(function (axis) {
                end[axis] = begin[axis] + 1;
                strides[axis] = 1;
            });
            // Figure out the output shape.
            var size = tfjs_1.backend_util.slice_util.computeOutShape(begin, end, strides);
            // Remove the axes based on shrinkMask.
            var outShape = size.filter(function (_, axis) { return shrinkAxes.indexOf(axis) === -1; });
            var nonStrided = strides.every(function (v) { return v === 1; });
            if (nonStrided) {
                return tfjs_1.reshape(tfjs_1.slice(x, begin, size), outShape);
            }
            var beginTensor = tfjs_1.tensor1d(begin, 'int32');
            for (var axis = 0; axis < end.length; axis++) {
                // Unlike Numpy, when the strides are negative, TF C uses -n-1 instead
                // of -1 as the "end" in order to include the first element.
                if (strides[axis] < 0 && end[axis] === -1) {
                    end[axis] -= x.shape[axis];
                }
            }
            var endTensor = tfjs_1.tensor1d(end, 'int32');
            var stridesTensor = tfjs_1.tensor1d(strides, 'int32');
            // Because tfjs allows begin, end and strides to be of different lengths
            // It has custom code (see above to handle the masking), so we do not
            // pass the mask info to the tensorflow backend.
            var opAttrs = [
                nodejs_kernel_backend_1.createTensorsTypeOpAttr('T', x.dtype),
                nodejs_kernel_backend_1.createTensorsTypeOpAttr('Index', 'int32'),
                { name: 'begin_mask', type: backend.binding.TF_ATTR_INT, value: 0 },
                { name: 'end_mask', type: backend.binding.TF_ATTR_INT, value: 0 },
                { name: 'ellipsis_mask', type: backend.binding.TF_ATTR_INT, value: 0 },
                { name: 'new_axis_mask', type: backend.binding.TF_ATTR_INT, value: 0 },
                { name: 'shrink_axis_mask', type: backend.binding.TF_ATTR_INT, value: 0 }
            ];
            var res = backend.executeSingleOutput(tfjs_1.StridedSlice, opAttrs, [x, beginTensor, endTensor, stridesTensor]);
            return tfjs_1.reshape(res, outShape);
        });
    }
};
